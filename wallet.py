import ecdsa
import codecs
import hmac
import secrets
import unicodedata
import hashlib # for SHA256 computation
import binascii # for conversion between Hexa and bytes
#%%
# secure random string
entropy = secrets.token_hex(16) # Generating a random secured entropy of 128 bits

#Verifying that the length of entropy is following BIP39 standard.
data = entropy.strip() #cleaning of data by removing spaces
data = binascii.unhexlify(data) #Return the binary data represented by the hexadecimal string data.

#%% Generating checksum and appending it to the end
# A checksum is generated by taking the first ENT/32 bits of its SHA256 hash.


hash_value = hashlib.sha256(data).hexdigest() # the function is going to calculate the hash of x using the sha256 algorithm and return the value in hex
print("Taille de l'entropie en hexa" ,len(data))
print("Taille de l'entropie en hexa fois 8" ,len(data)*8)
first_value = bin(int(binascii.hexlify(data),16))[2:].zfill(len(data)*8) 
# convert our data in hexadecimal, slice the binary value and fill it with zeros  such as the width the whole value
#is len(data)*8

print("Taille de l'entropie en hexa fois divs√© par 32" ,len(data)*8//32)
second_value  = bin(int(hash_value,16))[2:].zfill(256)[: len(data)* 8//32]
result = first_value + second_value

with open("english.txt", "r") as f:
         wordlist = [w.strip() for w in f.readlines()]
         
words_list= []
for i in range(len(result)//11):
    indx = int(result[11*i:11*(i+1)],2)
    words_list.append(wordlist[indx])

mnemonic = " ".join(words_list)
print("The mnemonic is : " ,mnemonic) 


#%% Creating root seed from mnemonic
normalized_mnemonic = unicodedata.normalize("NFKD",mnemonic)
password = " "
normalized_passphrase = unicodedata.normalize("NFKD", password)

passphrase = "mnemonic" + normalized_passphrase
encoded_mnemonic= normalized_mnemonic.encode("utf-8")
encoded_passphrase = passphrase.encode("utf-8")

binary_seed = hashlib.pbkdf2_hmac("sha512", encoded_mnemonic, encoded_passphrase, 2048)
binary_seed_hex = binascii.hexlify(binary_seed)
print("The root seed is : " ,binary_seed_hex)


#%% Generating keys

h_bsh = hmac.new(b"Bitcoin seed", binascii.unhexlify(binary_seed_hex.decode("utf-8")), hashlib.sha512).digest() #hash binary seed hex en bytes
print("\nHash value of the seed is : ", binascii.hexlify(h_bsh) )

m = h_bsh[:32]  # Master private key en bytes
print("\nMaster private key is : ", binascii.hexlify(m) ) 

c = h_bsh[32:] #chain code en bytes
print("\nChain code is : ", binascii.hexlify(c))

#%%
# Generating a public key in bytes using SECP256k1 & ecdsa library
public_key_raw = ecdsa.SigningKey.from_string(m, curve=ecdsa.SECP256k1).verifying_key
public_key_bytes = public_key_raw.to_string()
# Hex encoding the public key from bytes
public_key_hex = codecs.encode(public_key_bytes, 'hex')
# Bitcoin public key begins with bytes 0x04 so we have to add the bytes at the start
public_key = (b'04' + public_key_hex).decode("utf-8")

# Checking if the last byte is odd or even
if (ord(bytearray.fromhex(public_key[-2:])) % 2 == 0):
    public_key_compressed = '02'
else:
    public_key_compressed = '03'
    
# Add bytes 0x02 to the X of the key if even or 0x03 if odd
public_key_compressed += public_key[2:66]
print("The derived public key is : ", public_key_compressed)

#%% Generating children keys at a given index with a given derivation level

# Generating the parent private key (ECDSA compressed key)

private_key_raw = ecdsa.SigningKey.from_string(m, curve=ecdsa.SECP256k1).verifying_key
private_key_bytes = private_key_raw.to_string()
private_key_hex = codecs.encode(private_key_bytes, 'hex')
private_key = (b'04' + private_key_hex).decode("utf-8")

if (ord(bytearray.fromhex(private_key[-2:])) % 2 == 0):
    private_key_compressed = '02'
else:
    private_key_compressed = '03'
private_key_compressed += private_key[2:66]
        
niv_deriv = int(input("Enter a derivation level"))
index = int(input("Specify an index"))
i = 0

while(i < niv_deriv):       

    i += 1
    if (i == niv_deriv):
        ind = index
    else:
        ind = 0
    data = public_key_compressed + str(c) + str(ind)
    
    key = hmac.new(data.encode(), digestmod=hashlib.sha512).digest()
    result = private_key_compressed.encode() + key
    # mise a jour des parents et enfants 
    child_key =result[:32]
    child_chaincode = result[32:]
            
    print("The child key is : ", child_key)
    
